# -*- coding: utf-8 -*-
"""Movies CIS 545 Final Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1al5zaMCLZPSYQdD2bD5uEmxIaKiHBC7m

#CIS 545 Final Project: Movies 🎥 😛
Tony An, Daniel Da, Charlie Lu

## Motivation
For this project, we will be analyzing movie data. Specifically, we are looking to find whether certain factors (such as budget or rating) contribute to the success of a movie (measured by its revenue). At a high-level, we wish to accurately predict the success of the movie using regression techniques.

The findings of this project can be of interest to movie producers as well as investors. Producers can use this information to generate more profit from their movie by adjusting to incorporate factors that generally allow movies to generate more profit. In addition, investors can identify these movies with favorable attributes to invest in.

##Outline
These are the steps that will be taken in our project:


1.   Loading in appropriate datasets.
2.   Data cleaning and Feature Engineering
3.   Exploratory Data Analysis
4.   Analysis with Classification Models:
*   Logistic Regression
*   Decision Tree
*   Random Forest Classifier
*   Neural Network
5.   Analysis with Regression Models
*   Linear Regression
*   Ridge Regression
*   Lasso Regression
*   Random Forest Regressor
*   Gradient Boosting

## Rubric

![image.png](data:image/png;base64,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)

# Set Up and Loading in Data

This data includes three separate dataframes from Kaggle: ratings, credits, and movie metadata. The full data we used for this project can be found at https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset?select=ratings.csv.

There is roughly 50,000 movies released on or before July 2017. There is around 26 million ratings, allowing for robustness in our analysis. Since there are many individual datasets included in this, we chose the ones that included data that would be most relevant to the effect we are trying to measure.
"""

# importing necessary libraries
import json
import glob
import pandas as pd
import numpy as np
import datetime as dt
import re
import os
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import cm
from google.colab import drive
from sklearn.model_selection import train_test_split

sns.set(rc={'figure.figsize':(30,20)})
sns.set_palette("pastel")
sns.set(font_scale=2)

!apt update

from google.colab import drive
drive.mount('/content/drive')

!pip install kaggle

!mkdir ~/.kaggle

!cp /content/drive/MyDrive/kaggle.json ~/.kaggle/

!kaggle datasets download -d rounakbanik/the-movies-dataset

!unzip /content/the-movies-dataset.zip

credits = pd.read_csv("credits.csv")

movies = pd.read_csv("movies_metadata.csv")

movies_copy = movies.copy()

ratings = pd.read_csv("ratings.csv")

movies.dtypes

"""# Cleaning Dataset

## Movies
We first looked at our movies dataframe.
"""

movies.head(5)
movies.columns[movies.isna().any()].tolist()
movies = movies_copy.copy()

"""### Cleaning NA values

Since the volume of data we are using is large, it is expected that there are NA values in our dataset. However, we must ensure that certain attributes of interest, including revenue, id, runtime, release date, and status are not NA. This is because we will be using these values later on in our analysis. For the column that indicates the collection that the movie belongs to, we filled the NA value with an empty string, since it is not necessary for this a movie to have this attribute marked.
"""

movies = movies[movies['revenue'].notna()]
movies = movies[movies['imdb_id'].notna()]
movies = movies[movies['runtime'].notna()]
movies = movies[movies['release_date'].notna()]
movies = movies[movies['status'].notna()]
movies['belongs_to_collection'].fillna('', inplace = True)

movies.isnull().sum().sum()

"""We also check here to ensure that we only include movies that we have non-zero values for revenue and budget since there are primary variables that we want to measure in our models."""

movies = movies[movies['revenue'] != 0]
movies = movies[movies['budget'] != '0']

"""### Fixing type"""

movies.dtypes

movies['budget'] = pd.to_numeric(movies['budget'])

"""After checking for the types of the data, we convery the budget variable to a numeric (float) so that we can use it in our plots for EDA."""

movies['budget'] = movies['budget'].astype(float)
movies['popularity'] = movies['popularity'].astype(float)
movies['release_date'] = pd.to_datetime(movies['release_date'], format = '%Y-%m-%d')
movies['id'] = movies['id'].astype(int)

"""### Dropping unneeded columns"""

movies.drop(columns = ['status', 'video', 'title', 'imdb_id', 'overview'], inplace = True)
movies.drop(columns = ['poster_path', 'homepage', 'tagline'], inplace = True)

movies['adult'].unique()

"""This column only contains values with False. Seems pretty useless!"""

movies.drop(columns = 'adult', inplace = True)
#We drop this column.

"""### Checking for duplicates"""

movies[movies[['id']].duplicated(keep = False)].sort_values('id')

"""We see that there are duplicate values with the same id but somewhat different values in the vote_count and popularity columns. To fix this error, we'll take the average of the two values."""

columns = movies.columns.to_list()

columns.remove('vote_count')
columns.remove('popularity')

movies = movies.groupby(columns, as_index = False).mean()

movies[movies[['id']].duplicated(keep = False)]

"""No more duplicated values!

## Fixing outliers/parsing errors
"""

movies[(movies['budget'] < 1000) & (movies['revenue'] > 1000)]

"""There are some movies that have budgets less than \$1000 but revenues more than \$1000. A quick Google search shows that some of this data is incorrect (\$8 instead of \$8 million). We will manually fix these now."""

movies.loc[movies['original_title'] == 'Love, Wedding, Marriage', 'budget'] = 13000000
movies.loc[movies['original_title'] == 'Modern Times', 'budget'] = 1500000
movies.loc[movies['original_title'] == 'Less Than Zero', 'budget'] = 8000000
movies.loc[movies['original_title'] == '웰컴 투 동막골', 'budget'] = 8000000
movies.loc[movies['original_title'] == 'From Prada to Nada', 'budget'] = 1100000
movies.loc[movies['original_title'] == 'The Karate Kid, Part II', 'budget'] = 13000000
movies.loc[movies['original_title'] == 'Aquí Entre Nos', 'budget'] = 992000
movies.loc[movies['original_title'] == 'Nurse 3-D', 'budget'] = 10000000

# Manually fixing some of the weird budgets

movies = movies[movies['budget'] > 1000]

movies[movies['revenue'] < 1000]

"""Similarly, there appear to be some movies with revenues of less than \$1000. With some more searching online, we can find the correct number."""

movies.loc[movies['original_title'] == 'In the Cut', 'revenue'] = 23700000
movies.loc[movies['original_title'] == 'The Cookout', 'revenue'] = 12010000
movies.loc[movies['original_title'] == 'Never Talk to Strangers', 'revenue'] = 6858261
movies.loc[movies['original_title'] == 'Death at a Funeral', 'revenue'] = 49100000
movies.loc[movies['original_title'] == 'The End of Poverty?', 'revenue'] = 57805
movies.loc[movies['original_title'] == 'Duniyadari', 'revenue'] = 5120000
movies.loc[movies['original_title'] == 'Šišanje', 'revenue'] = 179979
movies.loc[movies['original_title'] == 'Dreaming of Joseph Lees', 'revenue'] = 12044
movies.loc[movies['original_title'] == 'Ladrón que roba a ladrón', 'revenue'] = 6875000
movies.loc[movies['original_title'] == 'A Perfect Man', 'revenue'] = 14147
movies.loc[movies['original_title'] == 'Deadfall', 'revenue'] = 18369
movies.loc[movies['original_title'] == 'Chasing Liberty', 'revenue'] = 12000000

movies = movies[movies['original_title'] != 'Die Angst des Tormanns beim Elfmeter']
movies = movies[movies['original_title'] != "Dr. Horrible's Sing-Along Blog"]
movies = movies[movies['original_title'] != "Все и сразу"]


#Could not find data on revenue

movies['return'] = movies['revenue'] / movies['budget']

"""The return on investment for a movie is the revenue divided by the budget. This column represents how much an investor would receive if they invested one dollar into the movie before development.

## Parsing genre
"""

import collections.abc

movies['genres'].head(2)

"""The data for genre comes in a difficult format. We'll define a function below to extract the genres into a list instead."""

def parse_genre(input):
  if (not isinstance(input, collections.abc.Sequence)):
    return input
  arr = input.split(",")
  genre_arr = []
  for genre in arr:
    if ('name' in genre):
      genre_arr.append(genre.split(": '")[1].split("'")[0])
  return genre_arr

movies['genres'] =movies['genres'].apply(lambda x: parse_genre(x))

movies['genres']

"""Since a movie can be multiple genres, we cannot have a single column to descrie the genre of a movie. Instead, we'll create a boolean column for each genre to represent whether the movie is or is not each genre. First, we need to create a set of all possible genres."""

from itertools import chain
genres = set(chain(*movies['genres']))
genres

"""Next, we create the column for each of the genres"""

for genre in genres:
  movies[genre] = movies['genres'].apply(lambda x: 1 if genre in x else 0)

"""We drop the original genres column because it is no longer needed."""

movies.drop(columns = 'genres', inplace = True)

"""## Parsing production company"""

movies['production_companies'].head(2)

"""Similar to genres, the production_companies column is in a difficult format. We'll handle this similarly by converting the column to a list of companies"""

def parse_company(input):
  if ('name' not in input):
    return input
  arr = input.split("name': '")
  company_arr = []
  for company in arr:
    if ('{' not in company) :
      company_arr.append(company.split("'")[0])
  return company_arr

movies['production_companies'] =movies['production_companies'].apply(lambda x: parse_company(x))

"""However, there are far too many production companies to create a column for each one. Instead, we found online (https://www.the-numbers.com/movies/production-companies/) the top grossing production companies and only sleected companies with over 30 trillion total worldwide box office. We will create a boolean column for each of these six companies."""

top_companies = ['Warner Bros', 'Universal Pictures', 'Columbia Pictures', 'Walt Disney', 'Paramount', 'Marvel']
# Companies with over 30 trillion total worldwide box office

"""The  function checks if the company is inside of the production_companies array and returns the correct boolean value. We use this function to also check for different monikers of the company (example is Walt Disney Pictures vs. Walt Disney)"""

def contains_company(target, input):
  for company in input:
    if target in company:
      return 1
  return 0

for company in top_companies:
  movies[company] = movies['production_companies'].apply(lambda x: contains_company(company, x))

movies.head(5)['production_companies']

"""## Credits features and merging

We extract relevant columns from the credits dataframe and merge into a cleaned dataframe with relevant columns.
"""

from ast import literal_eval

features = ['cast', 'crew']
for feature in features:
  credits[feature] = credits[feature].apply(literal_eval)

"""### Director"""

def get_director(x):
  for i in x:
    if i['job'] == 'Director':
      return i['name']

  return np.nan

credits['director'] = credits['crew'].apply(get_director)

"""### Writer"""

def get_writers(x):
  writers = []
  for i in x:
    if i['job'] == 'Screenplay':
      writers.append(i['name'])

  return writers

credits['writers'] = credits['crew'].apply(get_writers)

"""### Composer"""

def get_music(x):
  for i in x:
    if i['job'] == 'Original Music Composer':
      return i['name']

  return np.nan

credits['composer'] = credits['crew'].apply(get_music)

"""### Lead actor gender"""

def get_actors(x):
  actors = []
  for i in x[:3]:
    actors.append(i['name'])

  return actors

credits['actors'] = credits['cast'].apply(get_actors)

def male_lead_actor(x):
  for i in x[:1]:
    return 1 if i['gender'] == 2 else 0
  return 0

"""### Cast gender ratio"""

credits['lead_actor_male'] = credits['cast'].apply(male_lead_actor)

def cast_gender_ratio(x):
  total = 0
  male = 0
  for i in x[:5]:
    if i['gender'] == 2:
      male+=1
      total+=1
    else:
      total+=1
  if total == 0:
    return 0
  return male / total

credits['male_cast_ratio'] = credits['cast'].apply(cast_gender_ratio)

"""### Crew gender ratio"""

def crew_gender_ratio(x):
  total = 0
  male = 0
  for i in x[:5]:
    if i['gender'] == 2:
      male+=1
      total+=1
    else:
      total+=1
  if total == 0:
    return 0
  return male / total

credits['male_crew_ratio'] = credits['crew'].apply(cast_gender_ratio)

"""### Merging"""

df = movies.merge(credits, on = 'id', how = 'left')

df.dtypes

df.drop(columns = ['cast', 'crew'], inplace = True)

df.isna().sum()

"""## Ratings

For ratings, we do a similar approach and merge in relevant columns to our analysis.
"""

ratings.head(5)

ratings = ratings.groupby('movieId', as_index=False).mean()
ratings.drop(columns = ['userId', 'timestamp'], inplace = True)

all_ratings = df.merge(ratings, how = 'left', left_on = 'id', right_on = 'movieId').drop(columns = ['movieId'])

all_ratings.isna().sum()

"""There are too many null values for ratings -- much of the data doesn't line up with the movie data we currently have. Unfortunately, we'll have to exclude the ratings data.

## Feature engineering

### Above average

We want to create a binary variable that represents whether the movie is rated above average. First, let's look at the distribution of the vote_average variable again.
"""

df['vote_average'].describe()

"""The average vote isn't actually 5, instead it's actually 6.27.

We'll create a variable here to represent a binary on whether the vote average is greater than and equal to 6.3 or less than 6.3.
"""

df['above_avg'] = df['vote_average'].apply(lambda x: 1 if x >= 6.3 else 0)

"""### Return Quintiles"""

df['return'].describe()

"""Let's create a new column that represents the quintiles of return."""

quintiles = [0]
quintiles.extend(df['return'].quantile([0.2, 0.4, 0.6, 0.8, 1]))

# Create a new column that represents the quantiles of the values in the column
df['return_q'] = pd.cut(df['return'], quintiles, labels=[1, 2, 3, 4, 5])

df['return_q'] = df['return_q'].astype(int)

"""### Budget skewness"""

ax = sns.histplot(x = df['budget'],bins = 250)
ax.set(xlabel = 'Budget (in 100,000,000s)', ylabel = 'Count', title = 'Distribution of Movie Budget')
ax.plot()

"""Budget has some extreme skewness. As seen in the graph above, some movies have extraordinarily high budgets (above 100 million) while much of the movies included in the data have lower budgets. This skewness can affect our modeling by preventing the models from finding the relationship between the variables or lead to overfitting of the data. Thus, we will apply a log transformation to reduce the skewness of the data."""

df['l_budget'] = df['budget'].apply(lambda x: np.log(x))

ax = sns.histplot(x = df['l_budget'])
ax.set(xlabel = 'Budget', ylabel = 'Count', title = 'Distribution of the Natural Log of Movie Budget')
ax.plot()

"""### Return skewness"""

ax = sns.histplot(x = df['return'],bins = 250)
ax.set(xlabel = 'Return', ylabel = 'Count', title = 'Distribution of Movie Return')
ax.plot()

"""The skewness of return is extreme, so we definitely need to normalize this data. We'll first attempt a log transformation."""

df['l_return'] = df['return'].apply(lambda x: np.log(x))

ax = sns.histplot(x = df['l_return'])
ax.set(xlabel = 'Return', ylabel = 'Count', title = 'Distribution of Natural Log of Movie Return')
ax.plot()

"""The distribution is looking much more normal, so we can use this now.

### Season released
"""

spring = range(80, 172)
summer = range(172, 264)
fall = range(264, 355)

def get_season(date):
  doy = date.timetuple().tm_yday
  if doy in spring:
    return 'Spring'
  elif doy in summer:
    return 'Summer'
  elif doy in fall:
    return 'Fall'
  else:
    return 'Winter'

df['season'] = df['release_date'].apply(get_season)

df = pd.concat([df, pd.get_dummies(df["season"])], axis=1)
df.drop(columns = ['season'], inplace = True)

df.dtypes

"""### Series Movie

This feature represents if the movie is part of a collection or series of movies.
"""

df['series'] = df['belongs_to_collection'].apply(lambda x: 1 if len(x) > 0 else 0)

"""### Top Composers

Here we create a variable representing if the movie's composer is one of the top 3 movie composers of all time, according to [this source](https://www.the-numbers.com/box-office-star-records/worldwide/lifetime-specific-technical-role/composer). Hans Zimmer, John Williams, and Michael Giacchino all have contributed to movies for a total of 20 billion dollars of box office.
"""

df['top_composer'] = df['composer'].apply(lambda x: 1 if (x == 'Hans Zimmer') | (x == 'John Williams') | (x == 'Michael Giacchino') else 0)

"""### Top Actors

Here we create a column representing if the movie includes any of the top 10 highest grossing actors based on lead roles according to [Wikipedia](https://en.wikipedia.org/wiki/List_of_highest-grossing_actors).
"""

top_actors = pd.read_html('https://en.wikipedia.org/wiki/List_of_highest-grossing_actors')[3]['Actor'].apply(lambda x: str(x).strip())

top_actors

def has_top_actor(arr):
  for actor in arr:
    for top in top_actors:
      if actor == top:
        return 1
  return 0

df['top_actors'] = df['actors'].apply(has_top_actor)

"""### Top Director

Similar to the previous two columns, we create a column for whether the movie's director is one of the top 10 grossing directors.
"""

top_directors =  pd.read_html('https://en.wikipedia.org/wiki/List_of_highest-grossing_film_directors')[0]['Name']

top_directors

"""The dataset has Russo brothers under the elder brother, Anthony Russo"""

top_directors.replace('Russo brothers', 'Anthony Russo', inplace = True)

def has_top_director(director):
  for top in top_directors:
    if director == top:
      return 1
  return 0

df['top_director'] = df['director'].apply(has_top_director)

"""#EDA

## Preliminary Plots
"""

ax = sns.regplot(x = df['budget'], y = df['revenue'])
ax.set(xlabel = 'Budget', ylabel = 'Revenue', title = 'Revenue against budget')
ax.plot()

"""We find that in general, there tends to be a positive relationship between budget and revenue. This means that when the budget for a movie increases, it tends to generate more revenue. However, there are many outliers in this data, even though the line of best fit indicates a positive trend."""

ax = sns.regplot(x = df['budget'], y = df['return'])
ax.set(xlabel = 'Budget', ylabel = 'Return', title = 'Budget against return on investment')
ax.plot()

"""We plot the budget versus the return. Although the graph indicates no return, this actually is useful since return is comprised of Revenue - Budget. Thus, the graph indicates that profit of the movie does not actually depend on budget, since profits are small as a result of the general results that movies with higher revenues tend to have higher budgets. This means that when scaled, profit is not reliant on the budget. However, there are a couple of significantly large outliers in our data that might effect the findings of this graph."""

ax = sns.regplot(x = df[df['return'] < 200]['budget'], y = df[df['return'] < 200]['return'])
ax.set(xlabel = 'Budget', ylabel = 'Return', title = 'Budget against return on investment (absent of outliers)')
ax.plot()

"""After removing the outliers we identified earlier, the scale of the graph is more legible. However, the line of best fit here actually indicates a slight negative trend. This means that as budgets increase, the profits actually tends to decrease. Intuitively, this means that movies with larger budgets will struggle to generate a profit due to needing to make larger revenues to breakeven."""

sns.set(rc={'figure.figsize':(30,20)})
sns.set_palette("pastel")
sns.set(font_scale=2)

ax = sns.regplot(x = df['revenue'], y = df['return'])
ax.set(xlabel = 'Revenue', ylabel = 'Return', title = 'Revenue against return on investment')
ax.plot()

"""When plotting revenue against returns, we see that there is again no correlation. However, as before, the presense of large outliers in returns makes it difficult to accurately gauge any effect present."""

ax = sns.regplot(x = df[df['return'] < 200]['revenue'], y = df[df['return'] < 200]['return'])
ax.set(xlabel = 'Revenue', ylabel = 'Return', title = 'Revenue vs Return on Investment (absent of outliers)')
ax.plot()

"""After accounting for outliers, we see that there is a positive correlation between revenue and return. As with budget, this makes sense intuitively. Since return is comprised of Revenue - Budget, the higher revenue a movie has, the more profits it will earn."""

ax = sns.histplot(x = df['budget'])
ax.set(xlabel = 'Budget', ylabel = 'Count', title = 'Distribution of Movie Budgets')
ax.plot()

"""When looking at the distribution of budgets for different movies, we see that there are actually more movies with lower budgets. This means that in our data, there are more movies that cost less to produce."""

ax = sns.regplot(x = df['popularity'], y = df['revenue'])
ax.set(xlabel = 'Popularity', ylabel = 'Revenue', title = 'Revenue based on Popularity')
ax.plot()

"""In general, there is a positive correlation between popularity and revenue. However, we also obtained the confidence interval for this plot. The large confidence interval indicates that the linear relationship that we found may not actually fit the data as accurately. This is evident from the distribution of points as well. We see that there is a high concentration of data at the origin."""

ax = sns.regplot(x = df[df['return'] < 200]['popularity'], y = df[df['return'] < 200]['return'])
ax.set(xlabel = 'Popularity', ylabel = 'Return', title = 'Return based on Popularity (absent of outliers)')
ax.plot()

"""Running the returns based on popularity, however, gave better scaled results. There is still a positive correlation between popularity and returns, but the confidence interval is much smaller, indicating that this might be a more accurate representation of our data. This makes sense since returns are adjusted for the budget of the data, giving purely the profits from the data."""

ax = sns.regplot(x = df['runtime'], y = df['popularity'])
ax.set(xlabel = 'Runtime', ylabel = 'Popularity', title = 'Popularity Based on Runtime')
ax.plot()

"""We plot the runtime versus popularity. There is little effect found between these two variables. However, it is interesting to note that the majority of the movies are in the 75-150 minute range, with varying degrees of popularity. In addition, movies that are too long or too short tend to be less popular."""

ax = sns.regplot(x = df['runtime'], y = df['revenue'])
ax.set(xlabel = 'Runtime', ylabel = 'Revenue', title = 'Revenue Based on Runtime')
ax.plot()

"""When plotting runtime versus revenue however, we see that there is a positive effect. This may differ from popularity because many movies will generate revenue, even if their popularity is not high, since these two factors are independent of each other."""

ax = sns.regplot(x = df[df['return'] < 200]['runtime'], y = df[df['return'] < 200]['return'])
ax.set(xlabel = 'Runtime', ylabel = 'Return', title = 'Return Based on Runtime (absent of outliers)')
ax.plot()

"""When plotting runtime against return, however, we observe that there is actually a negative trend. As we identified earlier, this might be due to longer movies costing more to produce. Thus, the longer a movie is, the higher its budget is, leading to negative returns."""

ax = sns.histplot(x = df['release_date'])
ax.set(xlabel = 'Release Date', ylabel = 'Count', title = 'Distribution of Release Date')
ax.plot()

"""Next, we observe the general timeframe for which the movies we are analyzing. We find that many of the movies are produced in more recent years, evidently due to better data collection. Thus, it may not be wise to use release year as an indicator."""

ax = sns.lineplot(x = df[df['return'] < 200]['release_date'], y = df[df['return'] < 200]['return'])
ax.set(xlabel = 'Release Date', ylabel = 'Return', title = 'Returns Based on Release (absent of outliers)')
ax.plot()

"""Here, we plot the differences in returns for movies based on their release year. The graph indicates that the return on data appears to be stationary. We do not need to adjust for inflation in this case either since we are purely finding the profit, which returns the pure difference in values, already adjusted."""

df['year'] = pd.DatetimeIndex(df['release_date']).year
years = df.groupby('year', as_index = False).mean()
ax = sns.lineplot(x = years['year'], y = years['return'])
ax.set(xlabel = 'Release', ylabel = 'Return', title = 'Average return by year')
ax.plot()

"""Here, we aggregated by year. We find the average return by year for movies. Although there are some peaks and troughs, there is actually very little we can derive from this graph directly since each year's movie composition is likely different."""

df['year'] = pd.DatetimeIndex(df['release_date']).year
years = df.groupby('year', as_index = False).mean()
ax = sns.lineplot(x = years['year'], y = years['revenue'])
ax.set(xlabel = 'Release', ylabel = 'Revenue', title = 'Average revenue by year')
ax.plot()

"""When plotting revenue by year, we see a large spike in the late 1930s. In a historical context, this is likely due to the Great Depression and economic conditions. However, we see general positive trends in the data, although it tends to fluctuate. In the late 2010s, however, there is a large increase in revenue. However, we must note that revenue in this case, is not adjusted for inflation. Thus, the value of movies and costs are not measured on the same scale."""

corr_matrix = df[['budget', 'popularity', 'revenue', 'runtime', 'vote_average', 'vote_count', 'return']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""We can see that budget, revenue, and vote_count are all very correlated with each other. Interestingly, return is not correlated with revenue or budget, so this serves a good variable to predict. We will have to drop either budget or vote_count (vote_count seems like the better candidate to drop) to address this collinearity.

Additionally, we'll also drop revenue since this a variable that can only be realized after the movie release. Also, in a real world application, using this variable would yield results that are not very useful (predicting the future with the future).

Next, let's take a look at the correlation between some relevant features and the output variables.
"""

corr_matrix = df[['above_avg', 'return_q', 'budget', 'popularity', 'revenue', 'runtime', 'vote_count', 'return']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""We see that there tends to be some general correlation between the variables. However, return is evidently not correlated with any other variables.

## Feature Distribution
"""

df['season'] = df['release_date'].apply(get_season)
df.groupby(['season']).count().plot(kind='pie', y = 'id', autopct='%1.0f%%')
df.drop(columns = ['season'], inplace = True)

"""We see here that the distribution of movies released by season is generally evenly distributed, with summer slightly higher at 28% and winter the lowest at 22%. This means that for our analysis, season of release will be a valid variable and no scaling techniques will be necessary."""

df.groupby(['top_director']).count().plot(kind='pie', y = 'id', autopct='%1.0f%%')

"""We then looked at the distribution of whether the movie was produced by a top producer or not. In this case, 0 indicates that is was not, which is 98% of the movies in our dataset. The 1 indicates that the movie was produced by a top producer (2%) of the data. Because this distribution is highly imbalanced, this indicates that it may require resampling techniques to be applied to our data if we wish to use this as an indicator."""

df.groupby(['top_composer']).count().plot(kind='pie', y = 'id', autopct='%1.0f%%')

"""Similarly, we looked at the distribution of whether the movie's soundtrack was produced by a top composer or not. In this case, 0 indicates that is was not, which is 97% of the movies in our dataset. The 1 indicates that the movie was produced by a top producer (3%) of the data. Again, because this distribution is highly imbalanced, we may need to consider applying resampling techniques to our data."""

df.groupby(['series']).count().plot(kind='pie', y = 'id', autopct='%1.0f%%')

"""This indicator shows whether a movie is part of a series of movies not. Again, the binary 0 or 1 shows this in the chart. We see that 77% of the movies are not part of a series, whereas 23% are. This could be potentially useful in the modeling to determine whether movies that are part of a larger franchise or chain tend to do better."""

ax = sns.histplot(x = df['male_cast_ratio'])
ax.set(xlabel = 'Male cast ratio', ylabel = 'Count', title = 'Distribution of Ratio of Top Cast that is Male')
ax.plot()

"""The distribution of male cast ratio is highest for 0.4, 0.6, 0.8. This means that in general, the male to female ratio for casts ranges from 40-80%. As a whole, this is acceptable for our data because it centers around the average, indicating average split between genders."""

ax = sns.histplot(x = df['male_crew_ratio'])
ax.set(xlabel = 'Male crew ratio', ylabel = 'Count', title = 'Distribution of Ratio of Top Crew that is Male')
ax.plot()

"""However, we see that the male crew ratio varies slightly more, with values concentrated in the 60-100% range. This means that aside from just the case where the cast members are predominantly male, there are movies that have a higher concentration of male crew members. This may be a variable of interest to consider.

## Correlation Matrix
"""

corr_matrix = df[['budget', 'popularity', 'revenue', 'runtime', 'vote_average', 'vote_count', 'return']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""We can see that budget, revenue, and vote_count are all very correlated with each other. Interestingly, return is not correlated with revenue or budget, so this serves a good variable to predict. We will have to drop either budget or vote_count (vote_count seems like the better candidate to drop) to address this collinearity.

Additionally, we'll also drop revenue since this a variable that can only be realized after the movie release. Also, in a real world application, using this variable would yield results that are not very useful (predicting the future with the future).

Next, let's take a look at the correlation between some relevant features and the output variables.
"""

corr_matrix = df[['avg_rating', 'return_q', 'budget', 'popularity', 'runtime', 'return']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""No significant collinearity found! Interestingly, we see a slight correlation between the runtime and whether the movie is rated above average.

In this below correlation plot, we look at the non categorical features we are using in our models.
"""

corr_matrix = df[['runtime', 'popularity',
                   'lead_actor_male', 'male_cast_ratio', 'male_crew_ratio',
                   'l_budget', 'series',
                   'top_composer', 'top_actors', 'top_director', 'above_avg']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""Also no significant collinearity! Another interesting relationship between the log budget and ratio of male cast members. Do higher budget movies higher more male actors?

In the below correlation matrices, we'll take a look at collinearity in our dummy variables.

#### Genre
"""

corr_matrix = df[['Foreign', 'War', 'Crime', 'Western',
                   'Animation', 'Horror', 'Science Fiction', 'Documentary', 'TV Movie',
                   'Comedy', 'Action', 'Fantasy', 'Thriller', 'Adventure', 'Drama','History', 'Mystery', 'Romance', 'Family', 'Music']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""In most categorical dummy variables, we are to drop one of the variables to account for collinearity as the constant. However, for the Genre feature, a movie can have multiple genres. We see in our matrix that none of the pairs of genres seem to have siginificant collinearity, except the Family and Animated genres. This can be explained easily because most animated movies are targeted towards a younger audience with family!

#### Production Company
"""

corr_matrix = df[['Warner Bros','Universal Pictures', 'Columbia Pictures', 'Walt Disney', 'Paramount', 'Marvel']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""Similar to the genre variable, a movie can be a collaboration between multiple production companies. Since there's no collinearity in the matrix, we will keep all of the features too.

#### Season
"""

corr_matrix = df[['Fall', 'Spring', 'Summer', 'Winter']].corr()
sns.set(rc={'figure.figsize':(15,10)})
sns.heatmap(corr_matrix, cmap="RdBu",annot=True,vmax = 1, vmin = -1,center = 0)

"""Looks like there is quite a bit of collinearity for the four seasons. Note that a movie cannot be released in two different seasons. In this case, we'll just drop the season with the least movies to address for this collinearity which is Winter. We also know that we can easily deduce which movies are released in the winter if we know the other three seasons (it will when all three other season variables are 0s)."""

df.drop(columns = ['Winter'], inplace = True)

"""Since we create dummy variables out of the four seasons, we must drop the winter column.

# Preparing for Modeling

## Train Test Split
"""



features_bin = df.drop(columns = ['vote_average', 'above_avg', 'return', 'return_q', 'budget', 'l_return'])
votes = df['above_avg']
returns = df['l_return']

"""As mentioned early, we will be dropping the vote_count and revenue variables to address collinearity."""

features_bin.drop(columns = ['vote_count', 'revenue'], inplace = True)

features_bin.set_index('id', inplace = True)

features_bin.drop(columns = ['belongs_to_collection', 'original_title', 'original_language', 'production_companies', 'production_countries', 'release_date', 'spoken_languages', 'writers', 'composer', 'director', 'actors', 'year'], inplace = True)

features_bin.columns

# To use later for neural networks
cleaned = df[['above_avg', 'runtime', 'popularity', 'Mystery', 'Music', 'War', 'Drama',
       'Adventure', 'Science Fiction', 'Crime', 'Foreign', 'Fantasy',
       'Animation', 'Romance', 'Thriller', 'Western', 'History', 'Horror',
       'Action', 'TV Movie', 'Documentary', 'Family', 'Comedy', 'Warner Bros',
       'Universal Pictures', 'Columbia Pictures', 'Walt Disney', 'Paramount',
       'Marvel', 'lead_actor_male', 'male_cast_ratio', 'male_crew_ratio',
       'l_budget', 'Fall', 'Spring', 'Summer', 'series', 'top_composer',
       'top_actors', 'top_director']]

features_bin.dtypes

"""We split our data into train and test data. This is done twice for our binary predictions (predicting whether the movie has an above average rating) or for our numerical predictions (predicting the return of the movie)."""

x_train, x_test, y_train, y_test = train_test_split(features_bin, votes, test_size = .2, random_state = 888)

x_train2, x_test2, y_train2, y_test2 = train_test_split(features_bin, returns, test_size = .2, random_state = 888)

"""#Classification Models

In this section, we'll be predicting whether or not a movie will be rated above average using the 'above_avg' column we previously engineered. We'll be exploring a variety of classification models but we first initialize a simple way to keep track and compare each model's performance.
"""

class_scores = pd.DataFrame(columns={"Model": "object", "Accuracy": "float", "Precision": "float", "Recall": "float", "F1" : "float"})

"""## Logistic Regression

We'll first take a look at logistic regression.

### Standard logistic
"""

# TO-DO: Import required libraries

from sklearn.linear_model import LogisticRegression
# TO-DO: Initialize model with default parameters and fit it on the training set

log_reg = LogisticRegression(class_weight = 'balanced', max_iter = 2000).fit(x_train, y_train)
# TO-DO: Use the model to predict on the test set and save these predictions as `y_pred`
y_pred = log_reg.predict(x_test)
# TO-DO: Find the accuracy and store the value in `log_acc`
log_acc = log_reg.score(x_test, y_test)
train_score = log_reg.score(x_train, y_train)

train_score

log_acc

"""The train and test scores are nearly the same, suggesting overfitting is not a major issue here."""

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(log_reg, x_test, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

"""In terms of accuracy, logistic regression offers a decent baseline for our modeling. With an accuracy score of 71.1% and a precision score of 74.1%, we are clearly able to predict the outcome of a movie better than a coin flip!"""

from sklearn.metrics import recall_score
from sklearn.metrics import f1_score

class_scores.loc[len(class_scores.index)] = ['Logistic', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### With PCA Regression

Since there is the chance of multicollinearity in our data, we want to also test Principle Component Analysis for our modeling. This will capture more of the variance with less of the effects of multicollinearity to establish a better relationship between our predictors and outcome.
"""

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaler.fit(x_train)
scaled_x_train = scaler.transform(x_train)
scaled_x_test = scaler.transform(x_test)

pca = PCA(n_components=scaled_x_train.shape[1])
pca_x_train = pca.fit_transform(scaled_x_train)

cum_evr = np.cumsum(pca.explained_variance_ratio_)

plt.plot(np.arange(0, 39), np.cumsum(pca.explained_variance_ratio_))
plt.plot(np.arange(0, 39), [0.8]*39)
plt.xlabel('Number of components')
plt.ylabel('Cumulative explained variance ratio')
plt.title('Cum. explained var ratio against number of components')

"""In the above graph, we can se that the cumulative explained variance ratio seems to improve consistently as we add components. This may imply that PCA will not have a significant effect for our data. We'll still test it out, though.

The intersection between the 0.8 line and our explained variance ratio line is at n=24.
"""

pca = PCA(n_components=24)
pca_x_train = pca.fit_transform(scaled_x_train)
x_test_pca = pca.transform(scaled_x_test)

log_reg_pca = LogisticRegression(class_weight = 'balanced').fit(pca_x_train, y_train)
y_pred = log_reg_pca.predict(x_test_pca)
test_accuracy = log_reg_pca.score(x_test_pca, y_test)

test_accuracy

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(log_reg_pca, x_test_pca, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

"""Our accuracy and precision takes a small dip with PCA. It seems like multicollinearity is not a major issue here!"""

class_scores.loc[len(class_scores.index)] = ['Logistic with PCA', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### Coefficients of regression

The logistic regression without PCA performed the best, so we'll examine the coefficients of the variables for that model.
"""

coeff = log_reg.coef_[0]
plt.bar(range(len(coeff)), coeff)
plt.xticks(range(len(coeff)), x_train.columns, rotation=90)
plt.show()

"""While some of the genres do not have major effects on the outcome, it looks like animation and documentary films have a much higher chance of being rated above average, while horror and foreign films seem to be a lot less well-liked. Disney movies, along with Warner Bros to a lesser extent, have a high likelihood of being rated above average. Very interestingly, the impact of having a top composer is weighed heavier than having top actors or a top director. Although, music does have an enormous effect on the impact of a movie!

### Cross Validation
"""

from sklearn.model_selection import cross_val_score

scores = cross_val_score(estimator=log_reg,
X=x_train,y=y_train, cv=10)

print('Cross-validation accuracy scores: %s' %scores)
print('Cross-validation accuracy: %.3f +/- %.3f' % (np.mean(scores), np.std(scores)))

"""Here, we take a quick look at cross validation for a more robust evaluation of our model's performance by taking into account the train and test data's variability. In these results, we can see that the accuracy is pretty consistent across folds.

## Decision Trees

In this section we'll briefly explore using decision trees to predict whether a movie is rated above average.

### Standard decision tree classifier
"""

from sklearn.tree import DecisionTreeClassifier

clf = DecisionTreeClassifier(max_depth = 5)
clf.fit(x_train, y_train)
y_pred = clf.predict(x_test)
test_accuracy = clf.score(x_test, y_test)
train_accuracy = clf.score(x_train, y_train)

train_accuracy

test_accuracy

"""Our train and test accuracies are pretty even, so it seems like the model is not overfitting with the current hyperparameters!"""

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(clf, x_test, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

from sklearn import tree
fig = plt.figure(figsize=(150,100))
tree.plot_tree(clf, feature_names=x_train.columns,
               class_names = ['above average', 'below average'],
               filled=True)

"""This image is a little hard to view in CoLab, but opening it in another tab makes it a little more easy."""

class_scores.loc[len(class_scores.index)] = ['Decision Tree', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### Decision tree with PCA

We'll also examine if PCA has any effect on our model results for Decision Trees.
"""

from sklearn.tree import DecisionTreeClassifier

clf_pca = DecisionTreeClassifier(max_depth = 3)
clf_pca.fit(pca_x_train, y_train)
y_pred = clf_pca.predict(x_test_pca)
test_accuracy = clf_pca.score(x_test_pca, y_test)
train_accuracy = clf_pca.score(pca_x_train, y_train)

train_accuracy

test_accuracy

"""PCA makes the Decision tree perform worse than without."""

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(log_reg_pca, x_test_pca, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

class_scores.loc[len(class_scores.index)] = ['Decision Tree with PCA', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### Extra Trees Classifier

Since we discovered that PCA did not help with modeling, we will just use the standard feature data for the Extra Trees Classifier.
"""

from sklearn.ensemble import ExtraTreesClassifier

etc = ExtraTreesClassifier(max_depth = 15)
etc.fit(x_train, y_train)
y_pred = etc.predict(x_test)
test_accuracy = etc.score(x_test, y_test)
train_accuracy = etc.score(x_train, y_train)

train_accuracy

test_accuracy

"""#### With RandomSearchCV

This model seems to perform quite well with minimal tuning. Let's use RandomizedSearchCV to find the best hyperparameters for this model.
"""

from sklearn.model_selection import RandomizedSearchCV
from sklearn.tree import DecisionTreeClassifier
from scipy.stats import randint


param_grid = {
    "max_depth": [5, 7, 9, 10, 12, 14, 16, 18],
    "min_samples_split": randint(2, 5),
    "min_samples_leaf": randint(1, 9),
    "criterion": ["gini", "entropy"]
}

etc = ExtraTreesClassifier()

random_etc = RandomizedSearchCV(etc, param_grid, n_iter=30, cv=5, scoring="accuracy", n_jobs=-1)

random_etc.fit(x_train, y_train)

print("Best parameters:", random_etc.best_params_)
print("Best score:", random_etc.best_score_)

random_etc.score(x_test, y_test)

best_etc = random_etc.best_estimator_
y_pred = best_etc.predict(x_test)
train_score = best_etc.score(x_train, y_train)
test_score = best_etc.score(x_test, y_test)

train_score

test_score

"""There's a notable discrepencacy between the scores of the train and test data, indicating some overfitting of the model. This is difficult to control because of our lack of volume of data."""

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(best_etc, x_test, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

class_scores.loc[len(class_scores.index)] = ['Extra Trees', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### Feature importance

The extra trees classifier performed the best, so we'll take a look at the feature importance for this model.
"""

importance = best_etc.feature_importances_

plt.bar(range(len(importance)), importance)
plt.xticks(range(len(importance)), x_train.columns, rotation=90)
plt.show()

"""This offers some interesting differences from our logistic regression. As seen in the feature importnace chart, Animation movies are not as important but the Drama genre is very important. Beyond that, runtime, popularity, l_budget, and the male_crew_ratio are very important features that were not as apparent in the logistic regression.

## Random Forest Classifier#

### Standard Random Forest Classifier
"""

from sklearn.ensemble import RandomForestClassifier

forest = RandomForestClassifier(max_depth = 10)

forest.fit(x_train, y_train)

y_pred = forest.predict(x_test)

forest_score = forest.score(x_test, y_test)
train_score = forest.score(x_train, y_train)

train_score

forest_score

"""### With PCA Random Forest Classifier"""

from sklearn.ensemble import RandomForestClassifier

forest = RandomForestClassifier()

forest.fit(pca_x_train, y_train)

y_pred = forest.predict(x_test_pca)

forest_score = forest.score(x_test_pca, y_test)

forest_score

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

"""### With RandomizedSearchCV"""

import multiprocessing

pgrid = {
    'n_estimators': np.linspace(50,1000,20,dtype=int),
    'max_features': ['auto','sqrt','log2'],
    'max_depth': [3, 5, 7, 9, 11],
    'min_samples_leaf': [1,2,4],
    'min_samples_split': [2,4,8],
}

def random_forest_rs(pgrid,folds):
    rf_rs = RandomizedSearchCV(estimator=forest,
                               param_distributions=pgrid,
                               n_iter=30,
                               cv=folds,
                               verbose=10,
                               n_jobs= multiprocessing.cpu_count()-1,
                               random_state=42
                              ).fit(x_train,y_train)

    return rf_rs

rf_rs = random_forest_rs(pgrid,6)

print(f"Best parameters:\n{rf_rs.best_params_}")
print(f"Best score:\n{rf_rs.best_score_}")

best_rf = rf_rs.best_estimator_
test_score = best_rf.score(x_test, y_test)
train_score = best_rf.score(x_train, y_train)
y_pred = best_rf.predict(x_test)

train_score

test_score

"""There's still a discrepency between our train score and test score. This means that our model is overfitting the training data, leading to underperformance in our test data. However, due to the lack of volume of data, this overfitting is difficult to address in our Random Forest model. In our RandomizedSearchCV, we have already specified 6 folds, and increasing may worsen the hyperparameter tuning. Thus, we have decided to keep it at this."""

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(best_rf, x_test, y_test)

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

class_scores.loc[len(class_scores.index)] = ['Random Forest', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""### Feature importance"""

importance = best_rf.feature_importances_

plt.bar(range(len(importance)), importance)
plt.xticks(range(len(importance)), x_train.columns, rotation=90)
plt.show()

"""Looking at our feature importance graph, it looks pretty similar to the Decision Tree graph. Runtime, popularity, and l_budget are the most important features by far. In terms of genre, Drama and Horror films are important features in the likelihood of above average ratings. Additionally, we can see that the male_cast_ratio and male_crew_ratio are somewhat important factors.

## AdaBoost

For our next classification model, we'll try to use AdaBoost to fit the data. Adaboost uses a weak classifier to form a strong classifier by assigning higher weights to misclassified data.
"""

from sklearn.ensemble import AdaBoostClassifier

abc = AdaBoostClassifier(n_estimators = 100, learning_rate = 1)

abc.fit(x_train, y_train)

y_pred = abc.predict(x_test)

abc_score = abc.score(x_test, y_test)

abc_score

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

"""AdaBoost performs similarly at first to the other models.

### With PCA AdaBoost
"""

from sklearn.ensemble import AdaBoostClassifier

abc = AdaBoostClassifier(n_estimators = 100, learning_rate = 1)

abc.fit(pca_x_train, y_train)

y_pred = abc.predict(x_test_pca)

abc_score = abc.score(x_test_pca, y_test)

abc_score

from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_pred)

from sklearn.metrics import precision_score

precision_score(y_test, y_pred)

"""Similar to the other models, PCA negatively affects the model's performance.

### RandomizedSearchCV AdaBoost

We'll also try some RandomizedSearchCV for AdaBoost.
"""

from sklearn.model_selection import RandomizedSearchCV
from sklearn.ensemble import AdaBoostClassifier
from sklearn.tree import DecisionTreeClassifier

param_grid = {
    "base_estimator__max_depth": [1, 2, 3, 4, 5],
    "n_estimators": [50, 100, 200, 300, 400, 500],
    "learning_rate": [0.1, 0.2, 0.3, 0.4, 0.5],
}

adaboost = AdaBoostClassifier(base_estimator=DecisionTreeClassifier())

random_search = RandomizedSearchCV(adaboost, param_grid, n_iter=10, cv=5, scoring="accuracy", n_jobs=-1)

random_search.fit(x_train, y_train)


print("Best parameters:", random_search.best_params_)
print("Best score:", random_search.best_score_)

best_adb = random_search.best_estimator_

train_score = best_adb.score(x_train, y_train)
test_score = best_adb.score(x_test, y_test)
y_pred = best_adb.predict(x_test)

train_score

test_score

accuracy_score(y_test, y_pred)

precision_score(y_test, y_pred)

class_scores.loc[len(class_scores.index)] = ['AdaBoost', accuracy_score(y_test, y_pred), precision_score(y_test, y_pred), recall_score(y_test, y_pred), f1_score(y_test, y_pred)]

"""

### Feature importance"""

importance = best_adb.feature_importances_

plt.bar(range(len(importance)), importance)
plt.xticks(range(len(importance)), x_train.columns, rotation=90)
plt.show()

"""Once again, we see a pretty similar distribution for feature importance. Runtime, popularity, and l_budget have enormous importance when compared with the other features. Notably, we see that the Genre features and the gender ratio features have much lower importances here comparatively.

## Comparing models
"""

class_scores

"""## Neural Networks

**Creating a Custom Dataset for our Movies Dataframe**

In order to create a custom dataset, we must create an initializer and override the length and get item methods. While the methods may be trivial, we need to make sure that the get item method returns a tensor of (data, label), which proved to be a tad bit difficult.
"""

import torch
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import cm
from sklearn.model_selection import train_test_split
import torch
import torchvision
from torchvision import transforms, utils
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
from collections import Counter
from PIL import Image
from skimage import io, transform
import os
from torchvision.io import read_image
from torch.utils.data import Dataset, DataLoader
from collections import Counter
from google.colab import drive

class MoviesDataset(torch.utils.data.Dataset):
    def __init__(self, dataframe: pd.DataFrame):
        self.dataframe = dataframe

    def __len__(self):
        return len(self.dataframe)

    def __getitem__(self, index: int):
        dataset = self.dataframe.iloc[index]
        data = dataset
        data = data.drop("above_avg")

        sample = (torch.tensor(data.values.tolist()), dataset.above_avg)

        return sample

"""Next, we create the training and testing set by splitting our cleaned dataset with a 80:20 proportion."""

movies_train, movies_test = cleaned.sample(frac=0.8), cleaned.sample(frac=0.2)

"""Now, we create the datasets using what we've just created as our parameters for the custom dataset, and create appropriate loaders for these datasets."""

train_dataset = MoviesDataset(movies_train)
test_dataset = MoviesDataset(movies_test)

batch = 16
train_loader = torch.utils.data.DataLoader(train_dataset, batch_size = batch, shuffle = True, num_workers = 0)
test_loader = torch.utils.data.DataLoader(test_dataset, batch_size = batch, shuffle = True, num_workers = 0)

"""Now, we will create the FNN model.

We used an FNN model but weren't able to use a CNN model because this dataset doesn't really have image-like features. With the FNN, the difficult part became tuning our hyperparameters such that the accuracies ligned up properly. Initially, I thought that 39 features was little enough to not need more than one layer, but after many iterations, I came upon 3 linear layers. Next, fine tuning the parameters took many iterations as well, but this became the final result.
"""

class FNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(39, 20)
        self.relu1 = nn.ReLU()
        self.fc2 = nn.Linear(20, 12)
        self.relu2 = nn.ReLU()
        self.fc3 = nn.Linear(12, 2)

    def forward(self, x):
        outputs = self.flatten(x)
        outputs = self.fc1(outputs)
        outputs = self.relu1(outputs)
        outputs = self.fc2(outputs)
        outputs = self.relu2(outputs)
        outputs = self.fc3(outputs)
        return outputs

"""Next, we start training, using Cross Entropy Loss as our criterion and the Adam backbone as our optimizer. We print out the training accuracies as the model trains."""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# fnn = FNN().to(device)
# criterion = nn.CrossEntropyLoss()
# optimizer = optim.Adam(fnn.parameters(), lr=1e-4) #lr - learning step
# epoch = 25
# 
# acc_LIST_FNN = []
# loss_LIST_FNN = []
# acc_LIST_FNN_graph = []
# 
# for epoch in range(epoch):
#   running_loss = 0.0
#   correct = 0
#   total = 0
#   for inputs, labels in train_loader:
#       labels = labels.type(torch.LongTensor) # Cast to Long
#       inputs, labels = inputs.to(device), labels.to(device)
# 
#       optimizer.zero_grad()
#       outputs = fnn(inputs)
#       loss = criterion(outputs, labels)
#       loss.backward()
#       optimizer.step()
#       running_loss += loss.item()
# 
#       _, predicted = torch.max(outputs.data, 1)
#       total += labels.size(0)
#       correct += (predicted == labels).sum()
# 
#   accuracy = 100 * correct / total
#   accuracy_graph = 100 * correct.item() / total
#   acc_LIST_FNN_graph.append(accuracy_graph)
#   acc_LIST_FNN.append(accuracy)
#   loss_LIST_FNN.append(running_loss / len(train_loader)) # get the avg loss for each epoch
# 
#   print("The loss for Epoch {} is: {}, Accuracy = {}".format(epoch, running_loss/len(train_loader), accuracy))

"""Next, we graph the training accuracy vs. the epoch for our model."""

import matplotlib.pyplot as plt
import seaborn as sns

accuracy_nos = acc_LIST_FNN_graph
epoch_nos = list(range(25))
plt.plot(epoch_nos, accuracy_nos)
plt.title("Training Accuracy vs. Epoch for FNN")
plt.xlabel("Epoch Number")
plt.ylabel("Accuracy")

"""Now, we test our trained model with the testing set and look at the accuracy for the testing set as well."""

total = 0
correct = 0
with torch.no_grad():
    for images, labels in test_loader:
        labels = labels.type(torch.LongTensor) # Cast to Float
        images, labels = images.to(device), labels.to(device)
        outputs = fnn(images) # shape: torch.Size([10000, 10])
        _, predicted = torch.max(outputs.data, 1) # use max to get the prediction
        total += labels.size(0)
        correct += (predicted == labels).sum()

test_acc_FNN = 100 * correct / total
print('Test Accuracy: ' + str(test_acc_FNN))

"""Even after thorough hyperparameter tuning iterations, the accuracy turned out to be around 70-75% across iterations. We attributed this largely to the fact that a lot of data was lost during the process of cleaning our data. Although our initial dataset (especially the reviews dataset) was very gargantuan, the input for this particular model did not have too many samples. Despite looking for things like multicollinearity, we simply did not have a large enough dataset. We learned about a variety of methods to fix these issues like resampling or value imputation, which was unfortunately not possible without being disingenuous. We were confident, however, that with a larger training set, we would have much better results.

# Regression Models

We now run regression models to compare with the results of our classification model.

## Linear Regression
We start with a simple, unregularized, linear regression model.
"""

from sklearn.metrics import mean_squared_error

from sklearn.linear_model import LinearRegression

reg = LinearRegression().fit(x_train2, y_train2)

y_pred = reg.predict(x_test2)

score = reg.score(x_test2, y_test2)
print('Mean squared error:', mean_squared_error(y_test2, y_pred))

score

"""Wow, that's a bad score! Linear regression performs very poorly.

## Ridge Regression
"""

from sklearn.linear_model import Ridge

reg_ridge = Ridge(alpha = 10).fit(x_train2, y_train2)


y_pred = reg_ridge.predict(x_test2)


ridge_score = reg_ridge.score(x_test2, y_test2)
print('Mean squared error:', mean_squared_error(y_test2, y_pred))

ridge_score

"""A slightly less-bad bad-score, but not much change from linear. Ridge regression also performs poorly.

### With PCA
We apply Principle Component Analysis to reduce dimensionality in our data. This helps with issues of multicollinearity.
"""

scaler = StandardScaler()
scaler.fit(x_train2)
scaled_x_train = scaler.transform(x_train2)
scaled_x_test = scaler.transform(x_test2)

pca = PCA(n_components=scaled_x_train.shape[1])
pca_x_train2 = pca.fit_transform(scaled_x_train)

cum_evr = np.cumsum(pca.explained_variance_ratio_)

plt.plot(np.arange(0, 39), np.cumsum(pca.explained_variance_ratio_))
plt.plot(np.arange(0, 39), [0.8]*39)
plt.xlabel('Number of components')
plt.ylabel('Cumulative explained variance ratio')
plt.title('Cum. explained var ratio against number of components')

pca = PCA(n_components=24)
pca_x_train2 = pca.fit_transform(scaled_x_train)
x_test_pca2 = pca.transform(scaled_x_test)

from sklearn.linear_model import Ridge

reg_ridge = Ridge(alpha = 10.0).fit(pca_x_train2, y_train2)


y_pred = reg_ridge.predict(x_test_pca2)


ridge_score = reg_ridge.score(x_test_pca2, y_test2)
print('Mean squared error:', mean_squared_error(y_test2, y_pred))

ridge_score

"""PCA does not increase the score, so it may not be so useful in this case. This might indicate that multicollinearity has already been addressed thoroughly in data cleaning.

## Lasso Regression
"""

from sklearn.linear_model import Lasso

lasso_reg = Lasso(alpha=0.1)

lasso_reg.fit(x_train2, y_train2)

y_pred = lasso_reg.predict(x_test2)

lasso_score = lasso_reg.score(x_test2, y_test2)

print('Mean squared error:', mean_squared_error(y_test2, y_pred))

lasso_score

"""Lasso performs worse than Ridge. This might be because of the nature of our features. Lasso works best when there are few strong variables. However, this seems to not be the case in our model, indicating that we actually have variables that have little effect on our results.

### With PCA
"""

from sklearn.linear_model import Lasso

lasso_reg = Lasso(alpha=0.1)

lasso_reg.fit(pca_x_train2, y_train2)

y_pred = lasso_reg.predict(x_test_pca2)

lasso_score = lasso_reg.score(x_test_pca2, y_test2)

print('Mean squared error:', mean_squared_error(y_test2, y_pred))

lasso_score

"""PCA for Lasso is even worse! Again, since we might have addressed multicollinearity and there are not many strong features, Lasso is not fit for our data.

## Random Forest Regressor
"""

from sklearn.ensemble import RandomForestRegressor

model = RandomForestRegressor()

model.fit(x_train2, y_train2)

y_pred = model.predict(x_test2)

forest_score = model.score(x_test2, y_test2)

print('Mean squared error:', mean_squared_error(y_test2, y_pred))

forest_score

"""Our score for Random Forest is the best out of our regression models so far.

### With PCA
"""

from sklearn.ensemble import RandomForestRegressor

model = RandomForestRegressor()

model.fit(pca_x_train2, y_train2)

y_pred = model.predict(x_test_pca2)

forest_score = model.score(x_test_pca2, y_test2)

print('Mean squared error:', mean_squared_error(y_test2, y_pred))

forest_score

"""With PCA, we actually see that the score for Random Forest decreases. As mentioned above, this is likely due to a lack of multicollinearity in the data. The result of Random Forest with PCA is actually very similar to that of a regular Ridge Regression.

## Gradient Boost
"""

from sklearn.ensemble import GradientBoostingRegressor

gb = GradientBoostingRegressor()

gb.fit(x_train2, y_train2)

y_pred = gb.predict(x_test2)

gb_score = gb.score(x_test2, y_test2)


print('Mean squared error:', mean_squared_error(y_test2, y_pred))

gb_score

"""The Gradient Boosted model gives us the highest score, though it is not much higher than that of a Random Forest.

### With PCA
"""

from sklearn.ensemble import GradientBoostingRegressor

gb = GradientBoostingRegressor()

gb.fit(pca_x_train2, y_train2)

y_pred = gb.predict(x_test_pca2)

gb_score = gb.score(x_test_pca2, y_test2)


print('Mean squared error:', mean_squared_error(y_test2, y_pred))

gb_score

"""With PCA, this again performs very poorly. In fact, Gradient Boosting with PCA gives a worse result than a regular Ridge Regression and an Ordinary Least Squares Regression.

## Conclusions

Our classification models seem to offer some interesting conclusions. We can see that the genre of the movie manages to play an important factor in predicting whether a movie will be rated above average or below average. Notably, the Horror genre shows up across most of our models, indicating that it is a very important feature in determing the ratings (horror movies seem to be less likely to be rated well). Other important factors include the runtime of the movie, the popularity of the movie, and the budget of the movie.

We also found that having a higher ratio of male cast members and crew members are also important features in our models. This finding is pretty important because we know it doesn't imply that male cast and crew produce better movies --- moreso that the "top" of the industry is heavily male-dominated, something that is historically well-established. Across the models, however, we noticed that the presence of a male lead actor had differing effects on different models. Perhaps the actual actor on the screen has less of an effect.

Additionally, we would like to note that the presence of a top composer generally has higher feature importance than a top director or top actor. This is an interesting claim because, while music has always been an important facet of film, the director intuitively should be weighted more. This is not the case, since films with famous composers generally have a higher likelihood of being rated above average.

Across the genres, we can see a few dominating genres in terms of feature importance. Horror shows up across all models as one of the most important genre features, while Drama, Animation, and Comedy also appear frequently.

In the end, these feature importances obviously do not guarantee that a movie of a certain type will be perform well in theatres or even be rated above average. Our models never scored in the higher percentages for accuracy, and fairly only performed somewhat better than a coin flip. These findings depict rather trends in popular film culture and external factors that audiences may have that influence their ratings after. For example, horror movies can be emotionally stimulating, which is clearly not for all audiences. Thus, a general audience may be more likely to rate this movie lower. Animation movies, on the other hand, are generally targeted towards family audiences which may have better experiences in the movie theater together. These factors are all not captured by our model, and cannot be concretely confirmed by our results---only speculated.
"""

class_scores

"""No meaningful conclusions can be drawn from the regression models because our R^2 values were all pretty poor (our regressions were unable to explain much of the variance of the data). This indicates that the phenomenon of movies generating returns may simply be unpredictable, which makes sense in the real world. We also could be missing some important variables, such as promotion of the movie or some other measurements of movie quality.

In the real world, this makes sense. Some movies may have barebone production but a captivating premise, such as the Blair Wolf Project or Paranormal Activity, which both ended up achieving enormous returns on the initial budget. Other movies may have strong backings from larger companies, but measure consumer interest incorrectly, leading to low returns.

At the end of our project we'd like to present a few short snippets that are kind of interesting!
"""

df[df['Marvel'] == True].sort_values('return', ascending = True)[['original_title', 'release_date', 'budget', 'revenue', 'return']].head(5)

df[df['Marvel'] == True].sort_values('return', ascending = False)[['original_title', 'release_date', 'budget', 'revenue', 'return']].head(5)

df.sort_values('return', ascending = False)[['original_title', 'release_date', 'budget', 'revenue', 'return']].head(5)